C51 COMPILER V9.56.0.0   STC_EEPROM                                                        01/19/2025 23:01:07 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE STC_EEPROM
OBJECT MODULE PLACED IN ..\OBJ\stc_eeprom.obj
COMPILER INVOKED BY: D:\MDK\Keil_v5\C51\BIN\C51.EXE ..\FWLib\source\stc_eeprom.c LARGE OPTIMIZE(9,SIZE) BROWSE INCDIR(..
                    -\SYSTEM\delay;..\SYSTEM\sys;..\SYSTEM\init;..\FWLib\include;..\USER;..\HARDWARE\gpio;..\SYSTEM\uart;..\HARDWARE\max31865
                    -) DEBUG OBJECTEXTEND PRINT(..\OBJ\stc_eeprom.lst) TABS(2) OBJECT(..\OBJ\stc_eeprom.obj)

line level    source

   1          #include "config.h"
   2          #include "stc_eeprom.h"
   3          
   4          //========================================================================
   5          // 函数: void ISP_Disable(void)
   6          // 描述: 禁止访问ISP/IAP.
   7          // 参数: non.
   8          // 返回: non.
   9          // 版本: V1.0, 2012-10-22
  10          //========================================================================
  11          void  DisableEEPROM(void)
  12          {
  13   1        IAP_CONTR = 0;      //禁止IAP操作
  14   1        IAP_CMD   = 0;      //去除IAP命令
  15   1        IAP_TRIG  = 0;      //防止IAP命令误触发
  16   1        IAP_ADDRH = 0xff;   //清0地址高字节
  17   1        IAP_ADDRL = 0xff;   //清0地址低字节，指向非EEPROM区，防止误操作
  18   1      }
  19          
  20          //========================================================================
  21          // 函数: void EEPROM_Trig(void)
  22          // 描述: 触发EEPROM操作.
  23          // 参数: none.
  24          // 返回: none.
  25          // 版本: V1.0, 2014-6-30
  26          //========================================================================
  27          void EEPROM_Trig(void)
  28          {
  29   1        F0 = EA;    //保存全局中断
  30   1        EA = 0;     //禁止中断, 避免触发命令无效
  31   1        IAP_TRIG = 0x5A;
  32   1        IAP_TRIG = 0xA5;                    //先送5AH，再送A5H到IAP触发寄存器，每次都需要如此
  33   1                                            //送完A5H后，IAP命令立即被触发启动
  34   1                                            //CPU等待IAP完成后，才会继续执行程序。
  35   1        _nop_();
  36   1        _nop_();
  37   1        EA = F0;    //恢复全局中断
  38   1      }
  39          
  40          //========================================================================
  41          // 函数: void EEPROM_read_n(u16 EE_address,u8 *DataAddress,u16 number)
  42          // 描述: 从指定EEPROM首地址读出n个字节放指定的缓冲.
  43          // 参数: EE_address:  读出EEPROM的首地址.
  44          //       DataAddress: 读出数据放缓冲的首地址.
  45          //       number:      读出的字节长度.
  46          // 返回: non.
  47          // 版本: V1.0, 2012-10-22
  48          //========================================================================
  49          void EEPROM_read_n(u16 EE_address,u8 *DataAddress,u16 number)
  50          {
  51   1        IAP_ENABLE();                           //设置等待时间，允许IAP操作，送一次就够
  52   1        IAP_READ();                             //送字节读命令，命令不需改变时，不需重新送命令
  53   1        do
C51 COMPILER V9.56.0.0   STC_EEPROM                                                        01/19/2025 23:01:07 PAGE 2   

  54   1        {
  55   2          IAP_ADDRH = EE_address / 256;       //送地址高字节（地址需要改变时才需重新送地址）
  56   2          IAP_ADDRL = EE_address % 256;       //送地址低字节
  57   2          EEPROM_Trig();                      //触发EEPROM操作
  58   2          *DataAddress = IAP_DATA;            //读出的数据送往
  59   2          EE_address++;
  60   2          DataAddress++;
  61   2        }while(--number);
  62   1      
  63   1        DisableEEPROM();
  64   1      }
  65          
  66          //========================================================================
  67          // 函数: void EEPROM_SectorErase(u16 EE_address)
  68          // 描述: 把指定地址的EEPROM扇区擦除.
  69          // 参数: EE_address:  要擦除的扇区EEPROM的地址.
  70          // 返回: non.
  71          // 版本: V1.0, 2013-5-10
  72          //========================================================================
  73          void EEPROM_SectorErase(u16 EE_address)
  74          {
  75   1        IAP_ENABLE();                       //设置等待时间，允许IAP操作，送一次就够
  76   1        IAP_ERASE();                        //宏调用, 送扇区擦除命令，命令不需改变时，不需重新送命令
  77   1                                            //只有扇区擦除，没有字节擦除，512字节/扇区。
  78   1                                            //扇区中任意一个字节地址都是扇区地址。
  79   1        IAP_ADDRH = EE_address / 256;       //送扇区地址高字节（地址需要改变时才需重新送地址）
  80   1        IAP_ADDRL = EE_address % 256;       //送扇区地址低字节
  81   1        EEPROM_Trig();                      //触发EEPROM操作
  82   1        DisableEEPROM();                    //禁止EEPROM操作
  83   1      }
  84          
  85          //========================================================================
  86          // 函数: void EEPROM_write_n(u16 EE_address,u8 *DataAddress,u16 number)
  87          // 描述: 把缓冲的n个字节写入指定首地址的EEPROM.
  88          // 参数: EE_address:  写入EEPROM的首地址.
  89          //       DataAddress: 写入源数据的缓冲的首地址.
  90          //       number:      写入的字节长度.
  91          // 返回: non.
  92          // 版本: V1.0, 2012-10-22
  93          //========================================================================
  94          void EEPROM_write_n(u16 EE_address,u8 *DataAddress,u16 number)
  95          {
  96   1        IAP_ENABLE();                       //设置等待时间，允许IAP操作，送一次就够
  97   1        IAP_WRITE();                        //宏调用, 送字节写命令
  98   1        do
  99   1        {
 100   2          IAP_ADDRH = EE_address / 256;     //送地址高字节（地址需要改变时才需重新送地址）
 101   2          IAP_ADDRL = EE_address % 256;     //送地址低字节
 102   2          IAP_DATA  = *DataAddress;         //送数据到IAP_DATA，只有数据改变时才需重新送
 103   2          EEPROM_Trig();                    //触发EEPROM操作
 104   2          EE_address++;                     //下一个地址
 105   2          DataAddress++;                    //下一个数据
 106   2        }while(--number);                   //直到结束
 107   1        DisableEEPROM();
 108   1      }
 109          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    150    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      14
C51 COMPILER V9.56.0.0   STC_EEPROM                                                        01/19/2025 23:01:07 PAGE 3   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
